package randompoem

import scala.io.Source
import scala.util.Random

/**
 * Generates random poems according to a specified poem
 * grammar.
 *
 * The rules are read from a file and fed into a
 * Map[String, List[String]]. Each key is a string representing
 * the name of the rule, and the associated value is the rule definition
 * split by single space characters into a List[String].
 *
 * Poems are generated by calling 'parse' on the top level '<POEM>'
 * reference.
 *
 * Created by Nick Miano on 7/29/15.
 */
class RandomPoemGenerator(src: String) {
  //for randomly choosing a rule from a grouping of rules
  private val rand = new Random(System.currentTimeMillis())

  //regex patterns for parsing poem rules
  private val refPattern   = """(<[A-Z]+>)""".r
  private val groupPattern = """([\$<>a-zA-Z]+\|+[\$<>A-Za-z\|]+)""".r
  private val wordPattern  = """([a-z]+)""".r

  //poem generated from parsed grammar
  val poem: String = parse("<POEM>")

  /**
   * Recursively parses poem grammar rules to generate random poems
   *
   * - When a rule reference is encountered, it is looked up in the rule map.
   * If found, the List[String] defining the rule is folded into a string, with
   * parse being recursively called on each element of the List[String] before it
   * is folded in.
   *
   * - When a grouping is encountered, it is broken up into a List[String], an
   * element of which is randomly selected, with parse being recursively called
   * on the element.
   *
   * - When a word is encountered, it is simply returned
   *
   * - When a $LINEBREAK keyword is encountered, a '\n' is returned.
   *
   * - Everything else returns a 0 length String.
   * @param tok
   * @return
   */
  def parse(tok: String): String = tok match {
    case refPattern(s)   => ruleMap.getOrElse(s.replaceAll("<|>", ""), List())
                                   .foldRight("") { (x, acc) => parse(x) + acc }
    case groupPattern(s) => ({ (opts: String) =>
      val items: List[String] = opts.toString.split( """\|""").toList
      parse(items(rand.nextInt(items.size)))
    })(s)
    case wordPattern(s)  => s + " "
    case "$LINEBREAK"    => "\n"
    case _               => ""
  }


  /**
   * Returns a map in which each key is the name of a grammar rule,
   * and the corresponding value is a string representation of the rule's
   * definition.
   * @return map of rules
   */
  def ruleMap: Map[String, List[String]] = {
    //nested helper function for generating rule map from line
    def helper(line: String): Map[String, List[String]] = line.split(": ") match {
      case Array(k, v) => Map(k -> v.split(" ").toList)
      case _ => Map()
    }
    //read rules from file, and convert each line into a key value pair
    Source.fromFile(src).getLines().foldRight(Map[String, List[String]]()) { (x, acc) => acc ++ helper(x) }
  }
}
